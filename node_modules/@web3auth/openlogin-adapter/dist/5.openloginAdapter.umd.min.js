(window.webpackJsonpOpenloginAdapter=window.webpackJsonpOpenloginAdapter||[]).push([[5],{381:function(e,t,r){"use strict";r.d(t,"a",(function(){return u}));var n=r(339),i=r.n(n),o=r(444),a=r(2),s=r(389),c=r(384),p=r.n(c);function h(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function d(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?h(Object(r),!0).forEach((function(t){i()(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):h(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}class u extends o.a{constructor(e){let{config:t,state:r}=e;if(super({config:t,state:r}),i()(this,"_providerEngineProxy",null),!t.chainConfig)throw a.h.invalidProviderConfigError("Please provide chainConfig");if(!t.chainConfig.chainId)throw a.h.invalidProviderConfigError("Please provide chainId inside chainConfig");if(!t.chainConfig.rpcTarget)throw a.h.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");this.defaultState={chainId:"loading"},this.defaultConfig={chainConfig:t.chainConfig,networks:{[t.chainConfig.chainId]:t.chainConfig}},super.initialize()}get provider(){return this._providerEngineProxy}set provider(e){throw new Error("Method not implemented.")}addChain(e){if(!e.chainId)throw s.ethErrors.rpc.invalidParams("chainId is required");if(!e.rpcTarget)throw s.ethErrors.rpc.invalidParams("chainId is required");this.configure({networks:d(d({},this.config.networks),{},{[e.chainId]:e})})}getChainConfig(e){var t;const r=null===(t=this.config.networks)||void 0===t?void 0:t[e];if(!r)throw s.ethErrors.rpc.invalidRequest("Chain ".concat(e," is not supported, please add chainConfig for it"));return r}getProviderEngineProxy(){return this._providerEngineProxy}updateProviderEngineProxy(e){this._providerEngineProxy?this._providerEngineProxy.setTarget(e):this._providerEngineProxy=Object(o.b)(e)}}p()()},447:function(e,t){},448:function(e,t){},457:function(e,t){},464:function(e,t){},475:function(e,t){},689:function(e,t){},691:function(e,t){},708:function(e,t){},714:function(e,t){},763:function(e,t){},831:function(e,t){},839:function(e,t,r){"use strict";r.r(t),function(e){r.d(t,"EthereumPrivateKeyProvider",(function(){return S})),r.d(t,"WalletConnectProvider",(function(){return I}));var n=r(352),i=r.n(n),o=r(688),a=r(478),s=r(2),c=r(381),p=r(501),h=r(409),d=r.n(h),u=r(504),g=r.n(u),f=r(505),y=r(810),l=r(323);function w(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function m(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?w(Object(r),!0).forEach((function(t){i()(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):w(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function v(e){return 42===e.length}function P(e){let{getAccounts:t,getPrivateKey:r,processDecryptMessage:n,processEncryptionPublicKey:i,processEthSignMessage:o,processPersonalMessage:s,processTransaction:c,processSignTransaction:h,processTypedMessage:d,processTypedMessageV3:u,processTypedMessageV4:g}=e;if(!t)throw new Error("opts.getAccounts is required");async function f(e,r){if("string"==typeof e&&e.length>0){const n=(await t(r)).map(e=>e.toLowerCase()),i=e.toLowerCase();if(n.includes(i))return i}throw p.ethErrors.rpc.invalidParams({message:"Invalid parameters: must provide an Ethereum address."})}return Object(a.d)({eth_accounts:Object(a.c)((async function(e,r){r.result=await t(e)})),eth_private_key:Object(a.c)((async function(e,t){if(!r)throw p.ethErrors.rpc.methodNotSupported();t.result=r(e)})),eth_coinbase:Object(a.c)((async function(e,r){const n=await t(e);r.result=n[0]||null})),eth_sendTransaction:Object(a.c)((async function(e,t){if(!c)throw p.ethErrors.rpc.methodNotSupported();const r=e.params[0]||{from:""};r.from=await f(r.from,e),t.result=await c(r,e)})),eth_signTransaction:Object(a.c)((async function(e,t){if(!h)throw p.ethErrors.rpc.methodNotSupported();const r=e.params[0]||{from:""};r.from=await f(r.from,e),t.result=await h(r,e)})),eth_sign:Object(a.c)((async function(e,t){if(!o)throw p.ethErrors.rpc.methodNotSupported();const r=await f(e.params[0],e),n=e.params[1],i=m(m({},e.params[2]||{}),{},{from:r,data:n});t.result=await o(i,e)})),eth_signTypedData:Object(a.c)((async function(e,t){if(!d)throw p.ethErrors.rpc.methodNotSupported();const r=e.params[0],n=await f(e.params[1],e),i=m(m({},e.params[2]||{}),{},{from:n,data:r});t.result=await d(i,e,"V1")})),eth_signTypedData_v3:Object(a.c)((async function(e,t){if(!u)throw p.ethErrors.rpc.methodNotSupported();const r=await f(e.params[0],e),n={data:e.params[1],from:r,version:"V3"};t.result=await u(n,e,"V3")})),eth_signTypedData_v4:Object(a.c)((async function(e,t){if(!g)throw p.ethErrors.rpc.methodNotSupported();const r=await f(e.params[0],e),n={data:e.params[1],from:r,version:"V4"};t.result=await g(n,e,"V4")})),personal_sign:Object(a.c)((async function(e,t){if(!s)throw p.ethErrors.rpc.methodNotSupported();const r=e.params[0],n=e.params[1],i=e.params[2]||{};let o,a;if(v(r)&&!v(n)){let e="The eth_personalSign method requires params ordered ";e+="[message, address]. This was previously handled incorrectly, ",e+="and has been corrected automatically. ",e+="Please switch this param order for smooth behavior in the future.",t.warning=e,o=r,a=n}else a=r,o=n;o=await f(o,e);const c=m(m({},i),{},{from:o,data:a});t.result=await s(c,e)})),eth_getEncryptionPublicKey:Object(a.c)((async function(e,t){if(!i)throw p.ethErrors.rpc.methodNotSupported();const r=await f(e.params[0],e);t.result=await i(r,e)})),eth_decrypt:Object(a.c)((async function(e,t){if(!n)throw p.ethErrors.rpc.methodNotSupported();const r=e.params[0],i=await f(e.params[1],e),o=m(m({},e.params[2]||{}),{},{from:i,data:r});t.result=n(o,e)}))})}function b(e){const{getAccounts:t,getPrivateKey:r,processTransaction:n,processEthSignMessage:i,processTypedMessage:o,processTypedMessageV3:s,processTypedMessageV4:c,processPersonalMessage:p,processEncryptionPublicKey:h,processDecryptMessage:d}=e;return Object(a.e)([Object(a.d)({eth_syncing:!1}),P({getAccounts:t,getPrivateKey:r,processTransaction:n,processEthSignMessage:i,processTypedMessage:o,processTypedMessageV3:s,processTypedMessageV4:c,processPersonalMessage:p,processEncryptionPublicKey:h,processDecryptMessage:d})])}function O(e){return(t,r,n,i)=>"eth_chainId"===t.method?(r.result=e,i()):n()}function E(e){return(t,r,n,i)=>"eth_provider_config"===t.method?(r.result=e,i()):n()}function j(e){const{chainId:t,rpcTarget:r}=e,n=Object(o.a)({rpcTarget:r});return{networkMiddleware:Object(a.e)([O(t),E(e),n]),fetchMiddleware:n}}function C(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function T(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?C(Object(r),!0).forEach((function(t){i()(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):C(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}class I extends c.a{constructor(e){let{config:t,state:r,connector:n}=e;super({config:{chainConfig:T(T({},t.chainConfig),{},{chainNamespace:s.f.EIP155})},state:T(T({},r||{}),{},{chainId:"loading",accounts:[]})}),i()(this,"connector",null),this.connector=n||null}async enable(){if(!this.connector)throw p.ethErrors.provider.custom({message:"Connector is not initialized, pass wallet connect connector in constructor",code:4902});return await this.setupProvider(this.connector),this._providerEngineProxy.request({method:"eth_accounts"})}async setupProvider(e){this.onConnectorStateUpdate(e),await this.setupEngine(e)}async switchChain(e){let{chainId:t}=e;const r=this.getChainConfig(t),{ticker:n,tickerName:i,rpcTarget:o}=r;this.update({chainId:"loading"}),await this.connector.updateChain({chainId:Number.parseInt(t,16),nativeCurrency:{name:i,symbol:n},networkId:Number.parseInt(t,10),rpcUrl:o}),this.configure({chainConfig:r}),await this.lookupNetwork(this.connector)}async lookupNetwork(e){if(!e.connected)throw s.i.notConnectedError("Wallet connect connector is not connected");if(!this.provider)throw p.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const{chainId:t}=this.config.chainConfig,r=Object(s.k)(e.chainId.toString())?e.chainId:"0x".concat(e.chainId.toString(16));if(t!==r)throw s.h.rpcConnectionError("Invalid network, net_version is: ".concat(r,", expected: ").concat(t));return this.update({chainId:r}),this.provider.emit("connect",{chainId:t}),this.provider.emit("chainChanged",this.state.chainId),r}async setupEngine(e){const t=function(e){let{connector:t}=e;return{getPrivateKey:async()=>{throw p.ethErrors.rpc.methodNotSupported()},getAccounts:async e=>{const{accounts:r}=t;if(r&&r.length)return r;throw new Error("Failed to get accounts")},processTransaction:async(e,r)=>await t.sendTransaction(e),processSignTransaction:async(e,r)=>await t.signTransaction(e),processEthSignMessage:async(e,r)=>await t.signMessage([e.from,e.data]),processPersonalMessage:async(e,r)=>await t.signPersonalMessage([e.data,e.from]),processTypedMessage:async(e,r)=>{d.a.debug("processTypedMessage",e);return await t.signTypedData([e.from,e.data])},processTypedMessageV3:async e=>{throw p.ethErrors.rpc.methodNotSupported()},processTypedMessageV4:async e=>{throw p.ethErrors.rpc.methodNotSupported()},processEncryptionPublicKey:async e=>{throw p.ethErrors.rpc.methodNotSupported()},processDecryptMessage:e=>{throw p.ethErrors.rpc.methodNotSupported()}}}({connector:e});this.update({accounts:e.accounts||[]});const r=b(t),n=new a.a,{networkMiddleware:i}=j(this.config.chainConfig);n.push(r),n.push(i);const s=Object(o.b)(n);this.updateProviderEngineProxy(s),await this.lookupNetwork(e)}async onConnectorStateUpdate(e){e.on("session_update",async(t,r)=>{if(!this.provider)throw s.i.notConnectedError("Wallet connect connector is not connected");if(t)return void this.provider.emit("error",t);const{accounts:n,chainId:i,rpcUrl:o}=r;null!=n&&n.length&&this.state.accounts[0]!==n[0]&&(this.update({accounts:n}),this.provider.emit("accountsChanged",n));const a=Object(s.k)(i)?i:"0x".concat(i.toString(16));i&&this.state.chainId!==a&&(this.configure({chainConfig:T(T({},this.config.chainConfig),{},{chainId:a,rpcTarget:o})}),await this.setupEngine(e))})}}async function x(e,t){const{displayName:r,chainId:n}=t,i=e?u.Hardfork.London:u.Hardfork.Berlin,o={name:r,chainId:"loading"===n?0:parseInt(n,16),networkId:"loading"===n?0:Number.parseInt(n,10),hardfork:i};return g.a.custom(o)}function M(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function _(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?M(Object(r),!0).forEach((function(t){i()(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):M(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}i()(I,"getProviderInstance",async e=>{const t=new I({config:{chainConfig:e.chainConfig}});return await t.setupProvider(e.connector),t});class S extends c.a{constructor(e){let{config:t,state:r}=e;super({config:{chainConfig:_(_({},t.chainConfig),{},{chainNamespace:s.f.EIP155})},state:r})}async enable(){if(!this.state.privateKey)throw p.ethErrors.provider.custom({message:"Private key is not found in state, plz pass it in constructor state param",code:4902});return await this.setupProvider(this.state.privateKey),this._providerEngineProxy.request({method:"eth_accounts"})}async setupProvider(t){const r=b(function(t){let{privKey:r,chainConfig:n,getProviderEngineProxy:i}=t;return{getAccounts:async t=>["0x".concat(Object(l.privateToAddress)(e.from(r,"hex")).toString("hex"))],getPrivateKey:async e=>r,processTransaction:async(t,o)=>{const a=i();if(!a)throw p.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const s=await x(!!t.maxFeePerGas&&!!t.maxPriorityFeePerGas,n),c=f.TransactionFactory.fromTxData(t,{common:s}).sign(e.from(r,"hex")).serialize();return await a.request({method:"eth_sendRawTransaction",params:["0x".concat(c.toString("hex"))]})},processSignTransaction:async(t,i)=>{const o=await x(!!t.maxFeePerGas&&!!t.maxPriorityFeePerGas,n),a=f.TransactionFactory.fromTxData(t,{common:o}).sign(e.from(r,"hex")).serialize();return"0x".concat(a.toString("hex"))},processEthSignMessage:async(e,t)=>Object(o.c)(r,e.data),processPersonalMessage:async(t,n)=>{const i=e.from(r,"hex");return Object(y.personalSign)({privateKey:i,data:t.data})},processTypedMessage:async(t,n)=>{d.a.debug("processTypedMessage",t);const i=e.from(r,"hex");return Object(y.signTypedData)({privateKey:i,data:t.data,version:y.SignTypedDataVersion.V1})},processTypedMessageV3:async(t,n)=>{d.a.debug("processTypedMessageV3",t);const i=e.from(r,"hex");return Object(y.signTypedData)({privateKey:i,data:t.data,version:y.SignTypedDataVersion.V3})},processTypedMessageV4:async(t,n)=>{d.a.debug("processTypedMessageV4",t);const i=e.from(r,"hex");return Object(y.signTypedData)({privateKey:i,data:t.data,version:y.SignTypedDataVersion.V4})},processEncryptionPublicKey:async(e,t)=>(d.a.info("processEncryptionPublicKey",e),Object(y.getEncryptionPublicKey)(r)),processDecryptMessage:(t,n)=>{d.a.info("processDecryptMessage",t);const i=Object(l.stripHexPrefix)(t.data),o=e.from(i,"hex");return Object(y.decrypt)({encryptedData:JSON.parse(o.toString("utf8")),privateKey:r})}}}({privKey:t,chainConfig:this.config.chainConfig,getProviderEngineProxy:this.getProviderEngineProxy.bind(this)})),n=this.getChainSwitchMiddleware(),i=new a.a,{networkMiddleware:s}=j(this.config.chainConfig);i.push(r),i.push(n),i.push(this.getAccountMiddleware()),i.push(s);const c=Object(o.b)(i);this.updateProviderEngineProxy(c),await this.lookupNetwork()}async updateAccount(e){if(!this._providerEngineProxy)throw p.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});await this._providerEngineProxy.request({method:"eth_private_key"})!==e.privateKey&&(await this.setupProvider(e.privateKey),this._providerEngineProxy.emit("accountsChanged",{accounts:await this._providerEngineProxy.request({method:"eth_accounts"})}))}async switchChain(e){if(!this._providerEngineProxy)throw p.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const t=this.getChainConfig(e.chainId);this.update({chainId:"loading"}),this.configure({chainConfig:t});const r=await this._providerEngineProxy.request({method:"eth_private_key"});await this.setupProvider(r)}async lookupNetwork(){if(!this.provider)throw p.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const{chainId:e}=this.config.chainConfig;if(!e)throw p.ethErrors.rpc.invalidParams("chainId is required while lookupNetwork");const t=await this._providerEngineProxy.request({method:"net_version",params:[]});if(parseInt(e,16)!==parseInt(t,10))throw p.ethErrors.provider.chainDisconnected("Invalid network, net_version is: ".concat(t));return d.a.debug("this provider",this.provider,e,this.state.chainId),this.state.chainId!==e&&(this.provider.emit("chainChanged",e),this.provider.emit("connect",{chainId:e})),this.update({chainId:e}),t}getChainSwitchMiddleware(){return function(e){let{addChain:t,switchChain:r}=e;return Object(a.d)({wallet_addEthereumChain:Object(a.c)((async function(e,r){var n;const i=null!==(n=e.params)&&void 0!==n&&n.length?e.params[0]:void 0;if(!i)throw p.ethErrors.rpc.invalidParams("Missing chain params");if(!i.chainId)throw p.ethErrors.rpc.invalidParams("Missing chainId in chainParams");if(!i.rpcUrls||0===i.rpcUrls.length)throw p.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");if(!i.nativeCurrency)throw p.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");r.result=await t(i)})),wallet_switchEthereumChain:Object(a.c)((async function(e,t){var n;const i=null!==(n=e.params)&&void 0!==n&&n.length?e.params[0]:void 0;if(!i)throw p.ethErrors.rpc.invalidParams("Missing chainId");t.result=await r(i)}))})}({addChain:async e=>{const{chainId:t,chainName:r,rpcUrls:n,blockExplorerUrls:i,nativeCurrency:o}=e;this.addChain({chainNamespace:"eip155",chainId:t,ticker:(null==o?void 0:o.symbol)||"ETH",tickerName:(null==o?void 0:o.name)||"Ether",displayName:r,rpcTarget:n[0],blockExplorer:(null==i?void 0:i[0])||""})},switchChain:async e=>{const{chainId:t}=e;await this.switchChain({chainId:t})}})}getAccountMiddleware(){return function(e){let{updatePrivatekey:t}=e;return Object(a.d)({wallet_updateAccount:Object(a.c)((async function(e,r){var n;const i=null!==(n=e.params)&&void 0!==n&&n.length?e.params[0]:void 0;if(null==i||!i.privateKey)throw p.ethErrors.rpc.invalidParams("Missing privateKey");r.result=await t(i)}))})}({updatePrivatekey:async e=>{const{privateKey:t}=e;await this.updateAccount({privateKey:t})}})}}i()(S,"getProviderInstance",async e=>{const t=new S({config:{chainConfig:e.chainConfig}});return await t.setupProvider(e.privKey),t})}.call(this,r(3).Buffer)}}]);
//# sourceMappingURL=5.openloginAdapter.umd.min.js.map