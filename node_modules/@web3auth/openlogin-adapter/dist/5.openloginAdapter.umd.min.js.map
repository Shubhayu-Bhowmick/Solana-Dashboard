{"version":3,"sources":["webpack://OpenloginAdapter/../src/baseProvider.ts","webpack://OpenloginAdapter/../src/utils.ts","webpack://OpenloginAdapter/../src/rpc/walletMidddleware.ts","webpack://OpenloginAdapter/../src/rpc/ethRpcMiddlewares.ts","webpack://OpenloginAdapter/../src/rpc/jrpcClient.ts","webpack://OpenloginAdapter/../src/providers/injectedProviders/WalletConnectProvider.ts","webpack://OpenloginAdapter/../src/providers/injectedProviders/walletConnectUtils.ts","webpack://OpenloginAdapter/../src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","webpack://OpenloginAdapter/../src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts"],"names":["BaseProvider","BaseController","constructor","state","config","WalletInitializationError","chainId","chainConfig","networks","addChain","ethErrors","getChainConfig","getProviderEngineProxy","updateProviderEngineProxy","createEventEmitterProxy","getCreateRandomId","str","createWalletMiddleware","processTypedMessageV4","address","normalizedAccounts","getAccounts","accounts","_address","normalizedAddress","message","createScaffoldMiddleware","eth_accounts","createAsyncMiddleware","res","eth_private_key","getPrivateKey","eth_coinbase","eth_sendTransaction","txParams","req","from","validateAndNormalizeKeyholder","processTransaction","eth_signTransaction","processSignTransaction","eth_sign","msgParams","data","processEthSignMessage","eth_signTypedData","processTypedMessage","eth_signTypedData_v3","version","processTypedMessageV3","eth_signTypedData_v4","personal_sign","firstParam","secondParam","extraParams","resemblesAddress","warning","processPersonalMessage","eth_getEncryptionPublicKey","processEncryptionPublicKey","eth_decrypt","ciphertext","processDecryptMessage","createEthMiddleware","providerHandlers","mergeMiddleware","eth_syncing","createChainIdMiddleware","end","next","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","WalletConnectProvider","connector","chainNamespace","CHAIN_NAMESPACES","EIP155","code","method","currentChainConfig","Number","nativeCurrency","name","symbol","ticker","networkId","rpcUrl","WalletLoginError","connectedHexChainId","isHexStrict","getProviderHandlers","log","_","ethMiddleware","engine","networkMiddleware","provider","providerFromEngine","connectedChainId","displayName","hardfork","supportsEIP1559","Hardfork","customChainParams","parseInt","Common","providerFactory","params","EthereumPrivateKeyProvider","privateToAddress","Buffer","providerEngineProxy","common","getCommonConfiguration","signedTx","unsignedEthTx","signMessage","privKeyBuffer","personalSign","privateKey","signTypedData","SignTypedDataVersion","V1","V3","V4","getEncryptionPublicKey","stripped","stripHexPrefix","buff","decrypt","encryptedData","JSON","privKey","chainSwitchMiddleware","network","getChainSwitchMiddleware","createChainSwitchMiddleware","switchChain","wallet_addEthereumChain","chainParams","wallet_switchEthereumChain","tickerName","rpcUrls","blockExplorer","getAccountMiddleware","createAccountMiddleware","updatePrivatekey","wallet_updateAccount","accountParams"],"mappings":"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","file":"5.openloginAdapter.umd.min.js","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy } from '@toruslabs/base-controllers';\nimport { WalletInitializationError } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseProvider extends BaseController {\n  // should be Assigned in setupProvider\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_providerEngineProxy\", null);\n\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n\n  getChainConfig(chainId) {\n    var _this$config$networks;\n\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(\"Chain \".concat(chainId, \" is not supported, please add chainConfig for it\"));\n    return chainConfig;\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n}\n\nconst createRandomId = getCreateRandomId();\n\nexport { BaseProvider, createRandomId };\n//# sourceMappingURL=baseProvider.esm.js.map\n",null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, WalletLoginError, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport Common, { Hardfork } from '@ethereumjs/common';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { personalSign, signTypedData, SignTypedDataVersion, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { privateToAddress, stripHexPrefix } from 'ethereumjs-util';\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processTypedMessageV4: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state: _objectSpread$1(_objectSpread$1({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId\n    } = _ref2;\n    const currentChainConfig = this.getChainConfig(chainId);\n    const {\n      ticker,\n      tickerName,\n      rpcTarget\n    } = currentChainConfig;\n    this.update({\n      chainId: \"loading\"\n    });\n    await this.connector.updateChain({\n      chainId: Number.parseInt(chainId, 16),\n      nativeCurrency: {\n        name: tickerName,\n        symbol: ticker\n      },\n      networkId: Number.parseInt(chainId, 10),\n      rpcUrl: rpcTarget\n    });\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    await this.lookupNetwork(this.connector);\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = isHexStrict(connectedChainId) ? connectedChainId : \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nasync function getCommonConfiguration(supportsEIP1559, chainConfig) {\n  const {\n    displayName: name,\n    chainId\n  } = chainConfig;\n  const hardfork = supportsEIP1559 ? Hardfork.London : Hardfork.Berlin;\n  const customChainParams = {\n    name,\n    chainId: chainId === \"loading\" ? 0 : parseInt(chainId, 16),\n    networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 10),\n    hardfork\n  };\n  return Common.custom(customChainParams);\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    privKey,\n    chainConfig,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = getProviderHandlers({\n      privKey,\n      chainConfig: this.config.chainConfig,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n    log.debug(\"this provider\", this.provider, chainId, this.state.chainId);\n\n    if (this.state.chainId !== chainId) {\n      this.provider.emit(\"chainChanged\", chainId);\n      this.provider.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };\n//# sourceMappingURL=ethereumProvider.esm.js.map\n",null,null,null,null,null,null],"sourceRoot":""}