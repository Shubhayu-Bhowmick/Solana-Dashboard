{"version":3,"sources":["webpack://CustomauthAdapter/../src/baseProvider.ts","webpack://CustomauthAdapter/../src/utils.ts","webpack://CustomauthAdapter/../src/rpc/solanaRpcMiddlewares.ts","webpack://CustomauthAdapter/../src/providers/injectedProviders/injectedProviderProxy.ts","webpack://CustomauthAdapter/../src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","webpack://CustomauthAdapter/../src/providers/injectedProviders/phantom/providerHandlers.ts","webpack://CustomauthAdapter/../src/providers/injectedProviders/torus/torusInjectedProvider.ts","webpack://CustomauthAdapter/../src/providers/injectedProviders/torus/providerHandlers.ts","webpack://CustomauthAdapter/../src/rpc/JrpcClient.ts","webpack://CustomauthAdapter/../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","webpack://CustomauthAdapter/../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","webpack://CustomauthAdapter/../src/solanaWallet.ts"],"names":["BaseProvider","BaseController","constructor","state","config","WalletInitializationError","chainId","chainConfig","networks","addChain","ethErrors","getChainConfig","getProviderEngineProxy","updateProviderEngineProxy","createEventEmitterProxy","getCreateRandomId","createGetAccountsMiddleware","getAccounts","createAsyncMiddleware","async","request","response","next","method","accounts","createRequestAccountsMiddleware","requestAccounts","Error","createGenericJRPCMiddleware","targetMethod","handler","result","createSolanaMiddleware","providerHandlers","getPrivateKey","mergeMiddleware","createInjectedProviderProxyMiddleware","provider","res","PhantomInjectedProvider","chainNamespace","CHAIN_NAMESPACES","SOLANA","Promise","solanaMiddleware","injectedProvider","bs58","signTransaction","message","req","txn","Transaction","signMessage","params","signAndSendTransaction","signature","signAllTransactions","txns","msg","decodedMsg","getPhantomHandlers","injectedProviderProxy","engine","providerFromEngine","TorusInjectedProvider","code","connectedChainId","connectedHexChainId","isHexStrict","parseInt","data","buf","Buffer","messages","getTorusHandlers","createChainIdMiddleware","end","createProviderConfigMiddleware","providerConfig","SolanaPrivateKeyProvider","transactionGenerator","serializedTx","decodedTx","Message","keyPair","Keypair","transaction","nacl","_providerEngineProxy","signedTransactions","getProviderHandlers","networkMiddleware","rpcTarget","fetchMiddleware","createFetchMiddleware","createJsonRpcClient","privKey","health","getChainSwitchMiddleware","createChainSwitchMiddleware","switchSolanaChain","addNewChainConfig","nativeCurrency","rpcUrls","ticker","tickerName","displayName","blockExplorer","getAccountMiddleware","createAccountMiddleware","updatePrivatekey","privateKey","providerFactory","SolanaWallet","requireAllSignatures"],"mappings":"syBAesBA,UACZC,IAMRC,e,IAAY,eAAUC,GAAV,EAEV,GADA,MAAM,UAAUA,U,gCAH6C,OAIxDC,EAAL,YAAyB,MAAMC,+BAAN,8BACzB,IAAKD,cAAL,QAAiC,MAAMC,+BAAN,6CACjC,IAAKD,cAAL,UAAmC,MAAMC,+BAAN,+CACnC,kBAAoB,CAClBC,QAAS,WAEX,mBAAqB,CACnBC,YAAaH,EADM,YAEnBI,SAAU,CAAE,CAACJ,cAAD,SAA8BA,EAAOG,cAEnD,mBAGU,eACV,OAAO,KAAP,qBAGU,gBACV,MAAM,UAAN,2BAGKE,SAAQ,GACb,IAAKF,EAAL,QAA0B,MAAMG,8BAAN,uBAC1B,IAAKH,EAAL,UAA4B,MAAMG,8BAAN,uBAC5B,eAAe,CACbF,SAAQ,OAAO,YAAP,cAA6B,CAACD,EAAD,SAAuBA,MAIzDI,eAAc,G,MACnB,MAAMJ,EAAW,UAAG,YAAH,6BAAG,EAApB,GACA,MAAkB,MAAMG,iDAAN,qDAClB,SAGQE,yBACR,OAAO,KAAP,qBAGQC,0BAAyB,GAC7B,KAAJ,qBACG,uCAED,0BAA4BC,YAA5B,IClEwBC,O,+mBCYdC,K,IAA4B,YAAEC,GAAF,EAC1C,OAAOC,YAAsBC,MAAOC,EAASC,EAAUC,KACrD,MAAM,OAAEC,GAAR,EACA,mBAAIA,EAA0B,OAAOD,IAErC,MAAkB,MAAM,UAAN,oDAElB,MAAME,QAAiBP,EAAvB,GACAI,a,SAKYI,K,IAAgC,gBAC9CC,GAD8C,EAK5C,OAAKR,YAAsB,eAC3B,MAAM,OAAEK,GAAR,EACA,uBAAIA,EAA8B,OAAOD,IAEzC,MAAsB,MAAM,IAAIK,MAAV,wDAEtB,MAAMH,QAAiBE,EAAvB,GACAL,a,SAKYO,EACdC,EACAC,GAEE,OAAKZ,YAAkC,eACvC,MAAM,OAAEK,GAAR,EACA,GAAIA,IAAJ,EAA6B,OAAOD,IAEpC,MAAc,MAAM,yCAAN,kBAEd,MAAMS,QAAeD,EAArB,GAEAT,a,SAKYW,EAAuBC,GACnC,MAAI,6HAA2GC,GAAjH,EAEA,OAAOC,YAAgB,CACrBV,EAAgC,CAAEC,oBAClCV,EAA4B,CAAEC,gBAC9BW,EAA2B,kBAHN,GAIrBA,EAA2B,yBAJN,GAKrBA,EAA2B,sBALN,GAMrBA,EAA2B,cANN,GAOrBA,EAA2B,mBAP7B,K,uOC3DcQ,EAAsCC,GACpD,OAAOnB,YAAsB,eAC3B,MAAMa,QAAeM,U,iWAAAA,IAArB,IAGAC,a,ukBCCSC,UAAgCvC,IAC3CE,e,IAAY,eAAUC,GAAV,EACV,MAAM,CAAEC,OAAQ,CAAEG,YAAW,OAAOH,EAAP,iBAA2BoC,eAAgBC,IAAiBC,UAAYvC,UAG/E,qBACtB,OAAOwC,QAAP,UAGwB,uBACxB,MACMC,EAAmBZ,ECbMa,KACW,CAC1CnB,gBAAiB,SACRmB,YAA6B,CAACC,WAAYD,YAA1CA,YAAP,GAEF5B,YAAa,SAAa4B,YAA6B,CAACC,WAAYD,YAA1CA,YAJgB,GAK1CX,cAAe,UACb,MAAMxB,gBAAN,sBAEFqC,gBAAiB,UACf,MAAMC,EAAUF,WAAYG,SAA5B,SACMC,EAAMC,SAAZ,GAEA,aAD0BN,kBAA1B,IAGFO,YAAa,U,MAOX,aANsB,UAAqC,CACzD7B,OADyD,cAEzD8B,OAAQ,CACNL,QAAO,UAAEC,EAAF,2BAAEA,EAAYD,YAK3BM,uBAAwB,UACtB,MAAMN,EAAUF,WAAYG,SAA5B,SACMC,EAAMC,SAAZ,GAEA,MAAO,CAAEI,iBADWV,yBAApB,IAC0BU,YAE5BC,oBAAqB,U,QACnB,GAAI,UAACP,EAAD,sBAACA,EAAD,SAAwB,UAACA,EAAD,sBAACA,UAA7B,OACE,MAAMvC,8BAAN,WAEF,MAAM+C,EAAO,qBAAwBC,IACnC,MAAMC,EAAab,WAAnB,GACA,OAAOK,SAAP,KAGF,aAD0BN,sBAA1B,MD1BuBe,CAAzB,IAEMC,EAAwBzB,EAA9B,GACM0B,EAAS,IAAf,IACAA,UACAA,UACA,MAAMzB,EAAW0B,YAAjB,GAEA,wCACM,mBAAN,GAG2B,uBAC3B,MAAM,YAAExD,GAAgB,KAAxB,OAIA,OAHA,YAAY,CACVD,QAASC,EAAYD,UAEhBC,WAAP,I,ukBE1BSyD,UAA8BhE,IACzCE,e,IAAY,eAAUC,GAAV,EACV,MAAM,CAAEC,OAAQ,CAAEG,YAAW,OAAOH,EAAP,iBAA2BoC,eAAgBC,IAAiBC,UAAYvC,UAG/E,qBACtB,OAAOwC,QAAP,UAGwB,uBACxB,2CACM,iBAAN,GAG2B,sBAC3B,IAAK,KAAL,SAAoB,MAAM,4BAA0B,CAAEK,QAAF,2CAAuDiB,KAAM,OACjH,MAAM,QAAE3D,GAAY,YAApB,YAEM4D,QAAyB,sBAAuC,CACpE3C,OAAQ,mBAGJ4C,EAAsBC,YAAYF,EAAZE,0BAAmEC,SAAQ,EAARA,aAA/F,KACA,GAAI/D,IAAJ,EACE,MAAMD,2FAAN,IAKF,OAHA,YAAY,CAAEC,QAAS6D,IACvB,6BAA8B,CAAE7D,QAAS,WAAWA,UACpD,kCAAmC,WAAnC,SACO,WAAP,QAGuB,qBACvB,MACMsC,EAAmBZ,ECrCIa,KACa,CAC1CnB,gBAAiB,eACQ,UAAmC,CACxDH,OADwD,yBAExD8B,OAAQ,KAKZpC,YAAa,eACY,UAAmC,CACxDM,OADwD,kBAExD8B,OAAQ,KAKZnB,cAAe,UACb,MAAMxB,gBAAN,sBAGF0C,YAAa,U,MAOX,aANsB,UAAqC,CACzD7B,OADyD,eAEzD8B,OAAQ,CACNiB,KAAI,UAAErB,EAAF,2BAAEA,EAAYD,YAMxBD,gBAAiB,U,MACf,GAAI,UAACE,EAAD,sBAACA,EAAL,QACE,MAAMvC,8BAAN,WAEF,MAAMsC,EAAUF,WAAYG,SAAZH,kBAAhB,OACMzB,QAAiB,UAAiC,CACtDE,OADsD,mBAEtD8B,OAAQ,CAAEL,aAGNuB,EAAMC,SAAZ,OAEA,OADerB,SAAf,IAIFG,uBAAwB,U,MACtB,GAAI,UAACL,EAAD,sBAACA,EAAL,QACE,MAAMvC,8BAAN,WAEF,MAAMsC,EAAUF,WAAYG,SAAZH,kBAAhB,OAMA,MAAO,CAAES,gBAJc,UAAiC,CACtDhC,OADsD,mBAEtD8B,OAAQ,CAAEL,eAKdQ,oBAAqB,U,QACnB,GAAI,UAACP,EAAD,sBAACA,EAAD,SAAwB,UAACA,EAAD,sBAACA,UAA7B,OACE,MAAMvC,8BAAN,WAEF,MAAM+D,EAAN,GACA,IAAK,MAAL,KAA0BxB,SAA1B,QAA8C,CAC5C,MAAMD,EAAUF,uBAAhB,OACA2B,UAMF,aAJuB,UAAwC,CAC7DlD,OAD6D,wBAE7D8B,OAAQ,CAAEL,QAASyB,QDnCEC,CAAzB,IAEMb,EAAwBzB,EAA9B,GACM0B,EAAS,IAAf,IACAA,UACAA,UACA,MAAMzB,EAAW0B,YAAjB,GACA,wCACM,KAAN,gBAGwC,sCACxClB,uBAAuC,UACrC,0CAEFA,oBAAoC,UAClC,MAAMsB,EAAsBC,6BAAsCC,SAAQ,EAARA,aAAlE,KAEA,eAAe,CACb9D,YAAW,OAAO,YAAP,iBAAgCD,QAAS6D,YAEhD,mBAAN,M,SE7DUQ,EAAwBrE,GACtC,MAAO,WACL,mBAAI2C,UACFX,WACOsC,KAEFtD,I,SAIKuD,EAA+BC,GAC7C,MAAO,WAML,2BAAI7B,UACFX,WACOsC,KAEFtD,I,ukBCFEyD,UAAiC/E,IAC5CE,e,IAAY,eAAUC,GAAV,EACV,MAAM,CAAEC,OAAQ,CAAEG,YAAW,OAAOH,EAAP,iBAA2BoC,eAAgBC,IAAiBC,UAAYvC,UAYpF,eACjB,IAAK,WAAL,WACE,MAAM,4BAA0B,CAAE6C,QAAF,4EAAwFiB,KAAM,OAEhI,aADM,mBAAmB,WAAzB,YACO,kCAAqD,CAAE1C,OAAQ,iBAG9C,uBACxB,MAEMqB,EAAmBZ,QCtCtB,kB,IAAmC,iCAExCpB,GAFwC,EAOxC,MAAMoE,EAAwBC,IAC5B,MAAMC,EAAYpC,WAAlB,GAEA,OADWK,aAAqBgC,SAAhC,KAMF,oBAAI,EAA6B,MAAM9E,kBAAN,4BACjC,MAAM+E,EAHGC,kBAAsBb,SAA7B,QA4DF,MAxD4C,CAC1C9C,gBAAiB,SACR,CAAC0D,YAAR,YAEFnE,YAAa,SAAY,CAACmE,YAJgB,YAM1ClD,cAAe,SAN2B,EAQ1Ca,gBAAiB,U,QACf,GAAI,UAACE,EAAD,sBAACA,EAAL,QACE,MAAMvC,8BAAN,WAEF,MAAM4E,EAAcN,EAAoB,UAAC/B,EAAD,2BAACA,EAAzC,SAEA,OADAqC,iBACA,GAGFlC,YAAa,U,MACX,GAAI,UAACH,EAAD,sBAACA,EAAL,QACE,MAAMvC,8BAAN,WAGF,OADkB6E,kBAAmBtC,SAAnBsC,QAAuCH,EAAzD,YAIF9B,uBAAwB,U,QACtB,GAAI,UAACL,EAAD,sBAACA,EAAL,QACE,MAAMvC,8BAAN,WAEF,MAAM8E,EAAuB5E,IAC7B,MAA2B,MAAM,4BAA0B,CAAEoC,QAAF,8BAA0CiB,KAAM,OAE3G,MAAMqB,EAAcN,EAAoB,UAAC/B,EAAD,2BAACA,EAAzC,SACAqC,UAMA,MAAO,CAAE/B,gBAJS,UAAqC,CACrDhC,OADqD,kBAErD8B,OAAQ,CAACP,WAAYwC,EAAb,kBAKZ9B,oBAAqB,U,QACnB,GAAI,UAACP,EAAD,sBAACA,EAAD,SAAwB,UAACA,EAAD,sBAACA,UAA7B,OACE,MAAMvC,8BAAN,WAEF,MAAM+E,EAAN,GACA,IAAK,MAAL,KAAiB,mDAAjB,GAA4C,OAC1C,MAAMH,EAAcN,EAApB,GACAM,iBACAG,UAEF,WDjC6BC,CAAoB,WAAW9E,uBAAwB,0CAIhFkD,EAAS,IAAf,KACM,kBAAE6B,G,SDrBwBb,GAIlC,MAAM,oBAAWc,GAAjB,EACMC,EAAkBC,YAAsB,CAAEF,cAEhD,MAAO,mBADmBzD,YAAgB,CAACwC,EAAD,GAAmCE,EAAnC,GAA1C,IAC4BgB,mBCcIE,CAAoB,YAAlD,aACAjC,OAAY,KAAZA,4BACAA,OAAY,KAAZA,wBACAA,UACAA,UAEA,MAAMzB,EAAW0B,YAAjB,GAEA,wCAEM,KAAN,gBAGwB,uBACxB,IAAK,KAAL,qBAAgC,MAAM,4BAA0B,CAAEf,QAAF,8BAA0CiB,KAAM,aACtF,kCAAmD,CAAE1C,OAAQ,uBACnE8B,EAApB,mBACQ,mBAAmBA,EAAzB,YACA,iDAAkD,CAChD7B,eAAgB,kCAAqD,CAAED,OAAQ,uBAK7D,qBACtB,IAAK,KAAL,qBAAgC,MAAM,4BAA0B,CAAEyB,QAAF,8BAA0CiB,KAAM,OAChH,MAAM1D,EAAc,oBAAoB8C,EAAxC,SACA,YAAY,CACV/C,QAAS,YAEX,eAAe,CAAEC,gBACjB,MAAMyF,QAAgB,kCAAmD,CAAEzE,OAAQ,2BAC7E,mBAAN,GAG2B,sBAC3B,IAAK,KAAL,qBAAgC,MAAM,4BAA0B,CAAEyB,QAAF,8BAA0CiB,KAAM,OAChH,MAAMgC,QAAe,kCAAmD,CACtE1E,OADsE,YAEtE8B,OAAQ,MAEJ,YAAE9C,GAAgB,KAAxB,OACA,UAAI0F,EACF,MAAM5F,oFAAmGE,EAAzG,YAMF,OALA,YAAY,CAAED,QAASC,EAAYD,UAC/B,qBAAuBC,EAA3B,UACE,kCAAmC,WAAnC,SACA,6BAA8B,CAAED,QAAS,WAAWA,WAE/C,WAAP,QAGM4F,2BA0BN,O,SPvCYC,G,IAA4B,sCAAqBC,GAArB,EACxC,OAAKjE,YAAgB,CACrBP,EAA2B,iBADN,GAErBA,EAA2B,oBAF7B,KOqCgCuE,CAxBoB,CAChDE,kBAAmB,UACjB,IAAKpD,EAAL,OAAiB,MAAMvC,8BAAN,0BACjB,MAAM,mEAAkD4F,GAAmBrD,EAA3E,OAEA,MAAc,MAAMvC,8BAAN,kCACd,IAAI,GAAJ,IAAgB6F,SAAsB,MAAM7F,8BAAN,kCACtC,MAAqB,MAAMA,8BAAN,yCACrB,cAAc,CACZ8B,eAAgBC,IADJ,iBAGZ+D,QAAQ,0BAHI,MAIZC,YAAY,wBAJA,SAKZC,YALY,EAMZd,UAAWW,EANC,GAOZI,eAAe,sBAA0B,MAG7CP,kBAAmB,UACjB,IAAKnD,EAAL,OAAiB,MAAMvC,8BAAN,0BACjB,IAAKuC,SAAL,QAAyB,MAAMvC,8BAAN,yBACnB,iBAAiBuC,EAAvB,WAOE2D,uBASN,O,SPzCYC,G,IAAwB,iBAAEC,GAAF,EACpC,OAAK3E,YAAgB,CAACP,EAA2B,gBAAnD,KOwCSiF,CARmC,CACxCC,iBAAkB,UAChB,IAAK7D,EAAL,OAAiB,MAAMvC,8BAAN,0BACjB,IAAKuC,SAAL,WAA4B,MAAMvC,8BAAN,sBAC5B,MAAM,WAAEqG,GAAe9D,EAAvB,aACM,mBAAmB,CAAE8D,mB,IAlHtBhC,wBAKyB,UAIlC,MAAMiC,EAAkB,MAA6B,CAAE5G,OAAQ,CAAEG,YAAa8C,EAAO9C,eAErF,aADMyG,gBAA8B3D,EAApC,SACA,I,ME5BS4D,EAGX/G,YAAYmC,G,4BACV,gBAG0B,wBAK1B,aAJuB,sBAAgC,CACrDd,OADqD,kBAErD8B,OAAQ,KAKuB,gCACjC,MAAM,UAAEE,SAAoB,sBAA6C,CACvEhC,OADuE,yBAEvE8B,OAAQ,CACNL,QAAS,WAAY,YAAsB,CAAEkE,sBAAsB,QAGvE,MAAO,CAAE3D,aAGiB,yBAO1B,aANiC,sBAAsB,CACrDhC,OADqD,kBAErD8B,OAAQ,CACNL,QAAS,WAAY,YAAsB,CAAEkE,sBAAsB,QAMzC,6BAC9B,MAAMzC,EAAW,MAAkBa,GAC1B,WAAY,YAAsB,CAAE4B,sBAAsB,MAQnE,aANiC,sBAAsB,CACrD3F,OADqD,sBAErD8B,OAAQ,CACNL,QAASyB,KAMS,qBAOtB,aANuB,sBAAkC,CACvDlD,OADuD,cAEvD8B,OAAQ,CACNL,QAASsB,KAMK,iBAElB,aADqB,sBAArB,M","file":"4.customauthAdapter.umd.min.js","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy } from '@toruslabs/base-controllers';\nimport { WalletInitializationError } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseProvider extends BaseController {\n  // should be Assigned in setupProvider\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_providerEngineProxy\", null);\n\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n\n  getChainConfig(chainId) {\n    var _this$config$networks;\n\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(\"Chain \".concat(chainId, \" is not supported, please add chainConfig for it\"));\n    return chainConfig;\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n}\n\nconst createRandomId = getCreateRandomId();\n\nexport { BaseProvider, createRandomId };\n//# sourceMappingURL=baseProvider.esm.js.map\n",null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n",null,null,null,null,null,null,null,null,null],"sourceRoot":""}